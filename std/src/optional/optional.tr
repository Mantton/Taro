import std.panic.panic
import std.marker.Copy
import std.ops.FnOnce

/// An optional value that may or may not contain a wrapped value.
///
/// `Optional[T]` represents either `.some(value)` containing a value of type T,
/// or `.none` representing the absence of a value.
///
/// The shorthand syntax `T?` is equivalent to `Optional[T]`.
public enum Optional[Wrapped] {
    case some(Wrapped)
    case none
}


impl[Wrapped] Optional[Wrapped] {
    /// Create an Optional containing the given value.
    @inline
    public func new(_ wrapped: Wrapped) -> Self {
        .some(wrapped)
    }

    /// Returns true if the optional contains a value.
    @inline
    public func isSome(&self) -> bool {
        match self {
            case .some(_) => true
            case .none => false
        }
    }

    /// Returns true if the optional is empty.
    @inline
    public func isNone(&self) -> bool {
        match self {
            case .none => true
            case .some(_) => false
        }
    }
}

// Unwrapping methods - require Copy since we take &self but return Wrapped
impl[Wrapped: Copy] Optional[Wrapped] {
    /// Returns the contained value, panicking if none.
    ///
    /// Panics with a generic message if the optional is none.
    /// Prefer `expect` if you want a custom panic message.
    public func unwrap(&self) -> Wrapped {
        match self {
            case .some(v) => {
                *v
            }
            case .none => {
                panic("called unwrap on a none value")
            }
        }
    }

    /// Returns the contained value, panicking with the given message if none.
    public func expect(&self, _ message: string) -> Wrapped {
        match self {
            case .some(v) => {
                *v
            }
            case .none => {
                panic(message)
            }
        }
    }

    /// Returns the contained value or a default.
    @inline
    public func unwrapOr(&self, _ default: Wrapped) -> Wrapped {
        match self {
            case .some(v) => *v
            case .none => default
        }
    }

    /// Returns the contained value or computes it from a closure.
    public func unwrapOrElse[F: FnOnce[(), Wrapped]](&self, _ f: F) -> Wrapped {
        match self {
            case .some(v) => *v
            case .none => f()
        }
    }
}

// Transformation methods - require Copy since we take &self
impl[Wrapped: Copy] Optional[Wrapped] {
    /// Transforms the contained value using a function.
    ///
    /// Returns `.none` if the optional is none, otherwise returns
    /// `.some(f(value))`.
    public func map[U, F: FnOnce[Wrapped, U]](&self, _ f: F) -> Optional[U] {
        match self {
            case .some(v) => .some(f(*v))
            case .none => .none
        }
    }

    /// Transforms the contained value using a function that returns an Optional.
    ///
    /// This is useful for chaining operations that may fail.
    public func flatMap[U, F: FnOnce[Wrapped, Optional[U]]](&self, _ f: F) -> Optional[U] {
        match self {
            case .some(v) => f(*v)
            case .none => .none
        }
    }

    /// Returns the optional if it contains a value matching the predicate.
    public func filter[F: FnOnce[&Wrapped, bool]](&self, _ predicate: F) -> Optional[Wrapped] {
        match self {
            case .some(v) => {
                let val = *v
                if predicate(v) {
                    .some(val)
                } else {
                    .none
                }
            }
            case .none => .none
        }
    }
}

// Boolean combinators
impl[Wrapped] Optional[Wrapped] {
    /// Returns `.none` if self is `.none`, otherwise returns `other`.
    @inline
    public func and[U](&self, _ other: Optional[U]) -> Optional[U] {
        match self {
            case .some(_) => other
            case .none => .none
        }
    }
}

impl[Wrapped: Copy] Optional[Wrapped] {
    /// Returns the option if it contains a value, otherwise returns `other`.
    @inline
    public func or(&self, _ other: Self) -> Self {
        match self {
            case .some(v) => .some(*v)
            case .none => other
        }
    }
}

/// Convenience function to create a Some value.
public func Some[T](_ value: T) -> T? {
    .some(value)
}

/// Convenience function to create a None value.
public func None[T]() -> T? {
    .none
}
