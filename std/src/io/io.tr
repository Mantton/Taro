import std.mem.{Span, MutableSpan}
import std.result.Result

const IO_CHUNK_SIZE: usize = 4096

public func writeStdout(_ buf: *const uint8, _ len: usize) -> Result[usize, Error] {
    std.sys.io.writeStdout(buf, len)
}

public func writeStderr(_ buf: *const uint8, _ len: usize) -> Result[usize, Error] {
    std.sys.io.writeStderr(buf, len)
}

public func writeAll[W: Writer](_ writer: &mut W, _ buf: Span[uint8]) -> Result[(), Error] {
    let len = buf.len()
    if len == 0 {
        return .ok(())
    }

    var written: usize = 0
    while written < len {
        let remaining = buf.slice(written, len - written)
        let writeRes = writer.write(remaining)
        match writeRes {
            case .ok(count) => {
                if count == 0 {
                    return .err(Error.unexpected(0 as int32))
                }
                written += count
            }
            case .err(err) => return .err(err)
        }
    }

    return .ok(())
}

public func writeString[W: Writer](_ writer: &mut W, _ s: string) -> Result[(), Error] {
    let len = std.string.stringLen(s)
    if len == 0 {
        return .ok(())
    }

    let ptr = std.string.stringData(s)
    let bytes = Span[uint8].from(ptr, len)
    writeAll(writer, bytes)
}

public func readAll[R: Reader](_ reader: &mut R) -> Result[std.collections.List[uint8], Error] {
    var out = std.collections.List[uint8]()
    var storage: [uint8; IO_CHUNK_SIZE] = [0; IO_CHUNK_SIZE]
    let storagePtr = unsafe { (&mut storage as *mut [uint8; IO_CHUNK_SIZE]) as *mut uint8 }

    loop {
        let readBuf = MutableSpan[uint8].from(storagePtr, IO_CHUNK_SIZE)
        let readRes = reader.read(readBuf)
        match readRes {
            case .ok(count) => {
                if count == 0 {
                    break
                }

                var idx: usize = 0
                while idx < count {
                    out.append(*storage.at(idx))
                    idx += 1
                }
            }
            case .err(err) => return .err(err)
        }
    }

    return .ok(out)
}

public func readToString[R: Reader](_ reader: &mut R) -> Result[string, Error] {
    let bytesRes = readAll(reader)
    let bytes = match bytesRes {
        case .ok(value) => value
        case .err(err) => return .err(err)
    }

    let len = bytes.len()
    if len == 0 {
        return .ok("")
    }

    let data = std.mem.allocBytes(len)
    var idx: usize = 0
    while idx < len {
        data.add(idx).write(*bytes.at(idx))
        idx += 1
    }

    return .ok(std.string.stringFromParts(data, len))
}

public func readExact[R: Reader](_ reader: &mut R, _ buf: MutableSpan[uint8]) -> Result[(), Error] {
    let len = buf.len()
    if len == 0 {
        return .ok(())
    }

    var total: usize = 0
    var writable = buf
    while total < len {
        let tail = writable.slice(total, len - total)
        let readRes = reader.read(tail)
        let count = match readRes {
            case .ok(value) => value
            case .err(err) => return .err(err)
        }

        if count == 0 {
            return .err(Error.unexpected(0 as int32))
        }

        total += count
    }

    return .ok(())
}

public func readAtLeast[R: Reader](
    _ reader: &mut R,
    _ min: usize,
    _ buf: MutableSpan[uint8],
) -> Result[usize, Error] {
    let len = buf.len()
    if min > len {
        return .err(Error.invalidInput)
    }

    if min == 0 {
        return .ok(0)
    }

    var total: usize = 0
    var writable = buf
    while total < min {
        let tail = writable.slice(total, len - total)
        let readRes = reader.read(tail)
        let count = match readRes {
            case .ok(value) => value
            case .err(err) => return .err(err)
        }

        if count == 0 {
            return .err(Error.unexpected(0 as int32))
        }

        total += count
    }

    return .ok(total)
}

public func copy[R: Reader, W: Writer](_ reader: &mut R, _ writer: &mut W) -> Result[usize, Error] {
    var total: usize = 0
    var storage: [uint8; IO_CHUNK_SIZE] = [0; IO_CHUNK_SIZE]
    let storageMutPtr = unsafe { (&mut storage as *mut [uint8; IO_CHUNK_SIZE]) as *mut uint8 }
    let storagePtr = unsafe { storageMutPtr as *const uint8 }

    loop {
        let readBuf = MutableSpan[uint8].from(storageMutPtr, IO_CHUNK_SIZE)
        let readRes = reader.read(readBuf)
        let readCount = match readRes {
            case .ok(count) => count
            case .err(err) => return .err(err)
        }

        if readCount == 0 {
            break
        }

        let writeBuf = Span[uint8].from(storagePtr, readCount)
        let writeRes = writeAll(writer, writeBuf)
        match writeRes {
            case .ok(_) => {}
            case .err(err) => return .err(err)
        }

        total += readCount
    }

    return .ok(total)
}
