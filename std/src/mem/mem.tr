import std.optional.Optional
import std.panic.panic
import std.marker.Copy
import std.iter.{Iterator, Iterable}

public type TrackedPointer = *mut uint8

public struct Span[Element]: Copy {
    ptr: *const Element
    len: usize
}

public struct MutableSpan[Element]: Copy {
    ptr: *mut Element
    len: usize
}

impl[Element] Span[Element] {
    public func from(_ ptr: *const Element, _ len: usize) -> Self {
        return Span[Element] { ptr, len }
    }

    public func len(&self) -> usize {
        return self.len
    }

    public func isEmpty(&self) -> bool {
        return self.len == 0
    }

    public func at(&self, _ index: usize) -> &Element {
        if index >= self.len {
            panic("span index out of range")
        }
        return unsafe { self.ptr.add(index) as &Element }
    }

    public func get(&self, _ index: usize) -> Optional[&Element] {
        if index >= self.len {
            return .none
        }
        return .some(self.at(index))
    }

    public func slice(&self, _ start: usize, _ count: usize) -> Self {
        if start > self.len || count > (self.len - start) {
            panic("span slice out of range")
        }
        return Span[Element] {
            ptr: self.ptr.add(start),
            len: count,
        }
    }

    public func asBytes(&self) -> Span[uint8] {
        return Span[uint8] {
            ptr: unsafe { self.ptr as *const uint8 },
            len: self.len * sizeOf[Element](),
        }
    }
}

impl[Element] MutableSpan[Element] {
    public func from(_ ptr: *mut Element, _ len: usize) -> Self {
        return MutableSpan[Element] { ptr, len }
    }

    public func len(&self) -> usize {
        return self.len
    }

    public func isEmpty(&self) -> bool {
        return self.len == 0
    }

    public func at(&self, _ index: usize) -> &Element {
        if index >= self.len {
            panic("mutable span index out of range")
        }
        return unsafe { self.ptr.add(index) as &Element }
    }

    public func at(&mut self, _ index: usize) -> &mut Element {
        if index >= self.len {
            panic("mutable span index out of range")
        }
        return unsafe { self.ptr.add(index) as &mut Element }
    }

    public func get(&self, _ index: usize) -> Optional[&Element] {
        if index >= self.len {
            return .none
        }
        return .some(self.at(index))
    }

    public func get(&mut self, _ index: usize) -> Optional[&mut Element] {
        if index >= self.len {
            return .none
        }
        return .some(self.at(index))
    }

    public func slice(&self, _ start: usize, _ count: usize) -> Span[Element] {
        if start > self.len || count > (self.len - start) {
            panic("mutable span slice out of range")
        }
        return Span[Element] {
            ptr: unsafe { self.ptr.add(start) as *const Element },
            len: count,
        }
    }

    public func slice(&mut self, _ start: usize, _ count: usize) -> MutableSpan[Element] {
        if start > self.len || count > (self.len - start) {
            panic("mutable span slice out of range")
        }
        return MutableSpan[Element] {
            ptr: self.ptr.add(start),
            len: count,
        }
    }

    public func asConst(&self) -> Span[Element] {
        return Span[Element] {
            ptr: unsafe { self.ptr as *const Element },
            len: self.len,
        }
    }

    public func asBytes(&self) -> Span[uint8] {
        return Span[uint8] {
            ptr: unsafe { self.ptr as *const uint8 },
            len: self.len * sizeOf[Element](),
        }
    }

    public func asBytes(&mut self) -> MutableSpan[uint8] {
        return MutableSpan[uint8] {
            ptr: unsafe { self.ptr as *mut uint8 },
            len: self.len * sizeOf[Element](),
        }
    }
}

public struct SpanIterator[Element] {
    ptr: *const Element
    len: usize
    idx: usize
}

impl[Element] Iterator for SpanIterator[Element] {
    type Element = &Element

    public func next(&mut self) -> Optional[Self.Element] {
        if self.idx >= self.len {
            return .none
        }

        let value = unsafe { self.ptr.add(self.idx) as &Element }
        self.idx += 1
        return .some(value)
    }
}

impl[Element] Iterable for Span[Element] {
    type Iterator = SpanIterator[Element]
    type Element = &Element

    public func makeIterator(self) -> Self.Iterator {
        return SpanIterator[Element] {
            ptr: self.ptr,
            len: self.len,
            idx: 0,
        }
    }
}

public struct MutableSpanMutIterator[Element] {
    ptr: *mut Element
    len: usize
    idx: usize
}

impl[Element] Iterator for MutableSpanMutIterator[Element] {
    type Element = &mut Element

    public func next(&mut self) -> Optional[Self.Element] {
        if self.idx >= self.len {
            return .none
        }

        let value = unsafe { self.ptr.add(self.idx) as &mut Element }
        self.idx += 1
        return .some(value)
    }
}

impl[Element] Iterable for MutableSpan[Element] {
    type Iterator = MutableSpanMutIterator[Element]
    type Element = &mut Element

    public func makeIterator(self) -> Self.Iterator {
        return MutableSpanMutIterator[Element] {
            ptr: self.ptr,
            len: self.len,
            idx: 0,
        }
    }
}

public struct GcDesc {
    size: usize
    ptrOffsets: *const usize
    ptrCount: usize
}

extern "taro_rt" {
    func __gc__makebuf(_ desc: *const GcDesc, _ len: usize, _ cap: usize) -> TrackedPointer
    func __gc__grow_buf(_ old_ptr: TrackedPointer, _ desc: *const GcDesc, _ old_len: usize, _ new_cap: usize) -> TrackedPointer
    func __gc__desc_u8() -> *const GcDesc
}

public func allocBytes(_ len: usize) -> TrackedPointer {
    __gc__makebuf(__gc__desc_u8(), len, len)
}

public func sizeOf[T]() -> usize {
    std.intrinsic.__intrinsic_size_of[T]()
}

public func alignOf[T]() -> usize {
    std.intrinsic.__intrinsic_align_of[T]()
}
