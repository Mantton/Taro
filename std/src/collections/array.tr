import std.optional.Optional

public type Array[Element, const Size: usize] = [Element; Size]

extern "taro_intrinsic" {
    func __intrinsic_array_read_unchecked[Element, const Size: usize](
        _ arr: &[Element; Size],
        _ idx: usize,
    ) -> &Element
    func __intrinsic_array_read_mut_unchecked[Element, const Size: usize](
        _ arr: &mut [Element; Size],
        _ idx: usize,
    ) -> &mut Element
    func __intrinsic_array_write_unchecked[Element, const Size: usize](
        _ arr: &mut [Element; Size],
        _ idx: usize,
        _ value: Element,
    )
}

extend[Element, const Size: usize] Array[Element, Size] {
    public func len(&self) -> usize {
        Size
    }

    public func at(&self, _ idx: usize) -> &Element {
        if idx < Size {
            return __intrinsic_array_read_unchecked(self, idx)
        }
        std.print("index out of range\n")
        std.process.exit(1)
        return __intrinsic_array_read_unchecked(self, 0)
    }

    func at_mut(&mut self, _ idx: usize) -> &mut Element {
        if idx < Size {
            return __intrinsic_array_read_mut_unchecked(self, idx)
        }
        std.print("index out of range\n")
        std.process.exit(1)
        return __intrinsic_array_read_mut_unchecked(self, 0)
    }

    public func get(&self, _ idx: usize) -> Optional[&Element] {
        if idx < Size {
            return .some(self.at(idx))
        }
        return .none
    }

    public func get_mut(&mut self, _ idx: usize) -> Optional[&mut Element] {
        if idx < Size {
            return .some(self.at_mut(idx))
        }
        return .none
    }

    public func set(&mut self, _ idx: usize, _ value: Element) {
        if idx < Size {
            __intrinsic_array_write_unchecked(self, idx, value)
            return
        }
        std.print("index out of range")
        std.process.exit(1)
    }
}
