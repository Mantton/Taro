import std.optional.Optional
import std.mem.{Span, MutableSpan}

public type Array[Element, const Size: usize] = [Element; Size]

impl[Element, const Size: usize] Array[Element, Size] {
    public func len(&self) -> usize {
        Size
    }

    public func at(&self, _ idx: usize) -> &Element {
        if idx < Size {
            return unsafe { (self as *const Element).add(idx) as &Element }
        }
        std.print("index out of range\n")
        std.process.exit(1)
    }

    public func at(&mut self, _ idx: usize) -> &mut Element {
        if idx < Size {
            return unsafe { (self as *mut Element).add(idx) as &mut Element }
        }
        std.print("index out of range\n")
        std.process.exit(1)
    }

    public func get(&self, _ idx: usize) -> Optional[&Element] {
        if idx < Size {
            return .some(self.at(idx))
        }
        return .none
    }

    public func get(&mut self, _ idx: usize) -> Optional[&mut Element] {
        if idx < Size {
            return .some(self.at(idx))
        }
        return .none
    }

    public func set(&mut self, _ idx: usize, _ value: Element) {
        if idx < Size {
            unsafe { (self as *mut Element).add(idx).write(value) }
            return
        }
        std.print("index out of range")
        std.process.exit(1)
    }

    public func as_span(&self) -> Span[Element] {
        let ptr = unsafe { self as *const Element }
        return Span[Element].from(ptr, Size)
    }

    public func as_span(&mut self) -> MutableSpan[Element] {
        let ptr = unsafe { self as *mut Element }
        return MutableSpan[Element].from(ptr, Size)
    }
}
