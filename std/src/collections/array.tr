import std.optional.Optional

public type Array[Element, const Size: usize] = [Element; Size]

impl[Element, const Size: usize] Array[Element, Size] {
    public func len(&self) -> usize {
        Size
    }

    public func at(&self, _ idx: usize) -> &Element {
        if idx < Size {
            return unsafe { (self as *const Element).add(idx) as &Element }
        }
        std.print("index out of range\n")
        std.process.exit(1)
    }

    func atMut(&mut self, _ idx: usize) -> &mut Element {
        if idx < Size {
            return unsafe { (self as *mut Element).add(idx) as &mut Element }
        }
        std.print("index out of range\n")
        std.process.exit(1)
    }

    public func get(&self, _ idx: usize) -> Optional[&Element] {
        if idx < Size {
            return .some(self.at(idx))
        }
        return .none
    }

    public func getMut(&mut self, _ idx: usize) -> Optional[&mut Element] {
        if idx < Size {
            return .some(self.atMut(idx))
        }
        return .none
    }

    public func set(&mut self, _ idx: usize, _ value: Element) {
        if idx < Size {
            unsafe { (self as *mut Element).add(idx).write(value) }
            return
        }
        std.print("index out of range")
        std.process.exit(1)
    }
}
