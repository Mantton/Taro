import std.mem.{TrackedPointer, GcDesc, __gc__makebuf, __gc__grow_buf}
import std.intrinsic.__intrinsic_gc_desc
import std.optional.Optional
import std.iter.{Iterator, Iterable}


/// A dynamically-sized list (dynamic array).
///
/// List provides an automatically growing buffer that stores elements
/// contiguously in memory. Elements can be added with `append` and
/// accessed by index.
public struct List[Element] {
    buffer: TrackedPointer
    len: usize
    cap: usize
}

impl[Element] List[Element] {
    /// Create a new empty list.
    public func new() -> Self {
        List[Element] {
            buffer: TrackedPointer.null(),
            len: 0,
            cap: 0,
        }
    }

    /// Create a new list with the specified initial capacity.
    public func new(withCapacity capacity: usize) -> Self {
        if capacity == 0 {
            return List[Element]()
        }

        let desc = __intrinsic_gc_desc[Element]()
        let buf = __gc__makebuf(desc, 0, capacity)
        List[Element] {
            buffer: buf,
            len: 0,
            cap: capacity,
        }
    }

    /// Returns the number of elements in the list.
    public func len(&self) -> usize {
        self.len
    }

    /// Returns the current capacity of the list.
    public func capacity(&self) -> usize {
        self.cap
    }

    /// Returns true if the list is empty.
    public func isEmpty(&self) -> bool {
        self.len == 0
    }
}

impl[Element] List[Element] {
    /// Append an element to the end of the list.
    public func append(&mut self, _ item: Element) {
        if self.len >= self.cap {
            self.grow()
        }

        // Write the element to the buffer using the intrinsic
        unsafe {
            (self.buffer as *mut Element)
                .add(self.len)
                .write(item)
        }

        self.len += 1
    }

    /// Internal: grow the buffer capacity.
    func grow(&mut self) {
        let newCap = if self.cap == 0 { 4 } else { self.cap * 2 }

        let desc = __intrinsic_gc_desc[Element]()
        let newBuffer = __gc__grow_buf(self.buffer, desc, self.len, newCap)

        self.buffer = newBuffer
        self.cap = newCap
    }
}

impl[Element] List[Element] {
    /// Get a reference to the element at the given index, or none if out of bounds.
    public func get(&self, _ index: usize) -> Optional[&Element] {
        if index >= self.len {
            return .none
        }

        // Read the element from the buffer using the intrinsic
        let elem = unsafe { (self.buffer as *const Element).add(index) as &Element }
        return .some(elem)
    }

    /// Get a reference to the element at the given index, panicking if out of bounds.
    public func at(&self, _ index: usize) -> &Element {
        if index >= self.len {
            std.print("list index out of range\n")
            std.process.exit(1)
        }

        // Read the element from the buffer using the intrinsic
        return unsafe { (self.buffer as *const Element).add(index) as &Element }
    }

    /// Get a mutable reference to the element at the given index, or none if out of bounds.
    public func getMut(&mut self, _ index: usize) -> Optional[&mut Element] {
        if index >= self.len {
            return .none
        }

        let elem = unsafe { (self.buffer as *mut Element).add(index) as &mut Element }
        return .some(elem)
    }

    /// Get a mutable reference to the element at the given index, panicking if out of bounds.
    public func atMut(&mut self, _ index: usize) -> &mut Element {
        if index >= self.len {
            std.print("list index out of range\n")
            std.process.exit(1)
        }

        return unsafe { (self.buffer as *mut Element).add(index) as &mut Element }
    }
}

impl[Element] List[Element] {
    /// Set an element at the given index. Panics if out of bounds.
    public func set(&mut self, _ index: usize, _ value: Element) {
        if index >= self.len {
            std.print("list index out of range\n")
            std.process.exit(1)
        }

        unsafe {
            (self.buffer as *mut Element)
                .add(index)
                .write(value)
        }
    }

    /// Remove and return the last element, or none if the list is empty.
    public func pop(&mut self) -> Optional[Element] {
        if self.len == 0 {
            return .none
        }

        self.len -= 1
        let desc = __intrinsic_gc_desc[Element]()
        let elemSize = desc.size
        let offset = self.len * elemSize
        var elem: Element
        unsafe {
            let elemPtr = &mut elem as *mut Element
            let dst = elemPtr as *mut uint8
            self.buffer.byteAdd(offset).readBytes(dst, elemSize)
        }
        return .some(elem)
    }

    /// Clear all elements from the list.
    public func clear(&mut self) {
        self.len = 0
    }
}

public struct ListIterator[Element] {
    buffer: TrackedPointer
    len: usize
    idx: usize
}

impl[Element] Iterator for ListIterator[Element] {
    type Element = Element
    public func next(&mut self) -> Optional[Self.Element] {
        if self.idx >= self.len {
            return .none
        }

        let desc = __intrinsic_gc_desc[Element]()
        let elemSize = desc.size
        let offset = self.idx * elemSize
        var elem: Element
        unsafe {
            let elemPtr = &mut elem as *mut Element
            let dst = elemPtr as *mut uint8
            self.buffer.byteAdd(offset).readBytes(dst, elemSize)
        }

        self.idx += 1
        return .some(elem)
    }
}

public struct ListRefIterator[Element] {
    buffer: TrackedPointer
    len: usize
    idx: usize
}

impl[Element] Iterator for ListRefIterator[Element] {
    type Element = &Element
    public func next(&mut self) -> Optional[Self.Element] {
        if self.idx >= self.len {
            return .none
        }
        let elem = unsafe { (self.buffer as *const Element).add(self.idx) as &Element }
        self.idx += 1
        return .some(elem)
    }
}

impl[Element] Iterable for List[Element] {
    type Iterator = ListIterator[Element]
    type Element = Element
    public func makeIterator(self) -> Self.Iterator {
        ListIterator[Element] {
            buffer: self.buffer,
            len: self.len,
            idx: 0,
        }
    }
}

impl[Element] Iterable for &List[Element] {
    type Iterator = ListRefIterator[Element]
    type Element = &Element
    public func makeIterator(self) -> Self.Iterator {
        ListRefIterator[Element] {
            buffer: self.buffer,
            len: self.len,
            idx: 0,
        }
    }
}

public struct ListMutIterator[Element] {
    buffer: TrackedPointer
    len: usize
    idx: usize
}

impl[Element] Iterator for ListMutIterator[Element] {
    type Element = &mut Element

    public func next(&mut self) -> Optional[&mut Element] {
        if self.idx >= self.len {
            return .none
        }
        let elem = unsafe { (self.buffer as *mut Element).add(self.idx) as &mut Element }
        self.idx += 1
        return .some(elem)
    }
}

impl[Element] Iterable for &mut List[Element] {
    type Iterator = ListMutIterator[Element]
    type Element = &mut Element

    public func makeIterator(self) -> Self.Iterator {
        ListMutIterator[Element] {
            buffer: self.buffer,
            len: self.len,
            idx: 0,
        }
    }
}
