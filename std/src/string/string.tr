import std.hash.{Hashable, Hasher}
import std.ops.PartialEq
import std.mem.TrackedPointer
import std.mem.Span
import std.intrinsic.{
    __intrinsic_string_from_parts,
    __intrinsic_string_data,
    __intrinsic_string_len,
}

public func stringFromParts(_ data: TrackedPointer, _ len: usize) -> string {
    __intrinsic_string_from_parts(data, len)
}

public func stringData(_ s: string) -> *const uint8 {
    __intrinsic_string_data(s)
}

public func stringLen(_ s: string) -> usize {
    __intrinsic_string_len(s)
}

public func stringEq(_ lhs: string, _ rhs: string) -> bool {
    let lhs_len = stringLen(lhs)
    let rhs_len = stringLen(rhs)
    if lhs_len != rhs_len {
        return false
    }
    if lhs_len == 0 {
        return true
    }

    let lhs_ptr = stringData(lhs)
    let rhs_ptr = stringData(rhs)
    var idx: usize = 0

    while idx < lhs_len {
        if lhs_ptr.add(idx).read() != rhs_ptr.add(idx).read() {
            return false
        }
        idx += 1
    }

    return true
}

impl Hashable for string {
    public func hash[H: Hasher](&self, into hasher: &mut H) {
        let len = stringLen(*self)
        let data = stringData(*self)
        let bytes = Span[uint8].from(data, len)
        hasher.write(bytes)

        // Rust-style str hashing: append 0xff delimiter so sequential string
        // hashing remains prefix-safe ("ab","c" != "a","bc").
        let delimiter: [uint8; 1] = [0xff]
        hasher.write(delimiter.as_span())
    }
}

impl PartialEq for string {
    public func eq(&self, _ other: &string) -> bool { stringEq(*self, *other) }
}
