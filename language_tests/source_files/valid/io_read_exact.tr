// TEST

@test
func testReadExactSuccess() {
    let path = "taro_io_read_exact_success.txt"
    let content = "abcdef"
    let contentLen = std.string.stringLen(content)
    let contentPtr = std.string.stringData(content)

    std.assert(std.fs.writeString(path, content).isOk(), "failed to write readExact success file")

    let openRes = std.fs.File.open(path)
    var reader = match openRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to open readExact success file")
    }

    var storage: [uint8; 6] = [0; 6]
    let storagePtr = unsafe { (&mut storage as *mut [uint8; 6]) as *mut uint8 }
    let buf = std.mem.MutableSpan[uint8].from(storagePtr, 6)
    std.assert(std.io.readExact(&mut reader, buf).isOk(), "readExact should succeed")

    var idx: usize = 0
    while idx < contentLen {
        std.assert(*storage.at(idx) == contentPtr.add(idx).read(), "readExact byte mismatch")
        idx += 1
    }

    std.assert(reader.close().isOk(), "failed to close readExact success file")
    std.assert(std.fs.removeFile(path).isOk(), "failed to remove readExact success file")
}

@test
func testReadExactUnexpectedEof() {
    let path = "taro_io_read_exact_eof.txt"
    std.assert(std.fs.writeString(path, "abc").isOk(), "failed to write readExact eof file")

    let openRes = std.fs.File.open(path)
    var reader = match openRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to open readExact eof file")
    }

    var storage: [uint8; 5] = [0; 5]
    let storagePtr = unsafe { (&mut storage as *mut [uint8; 5]) as *mut uint8 }
    let buf = std.mem.MutableSpan[uint8].from(storagePtr, 5)
    let readRes = std.io.readExact(&mut reader, buf)
    std.assert(readRes.isErr(), "readExact should fail on short input")
    match readRes {
        case .ok(_) => std.panic.panic("expected readExact eof to fail")
        case .err(err) => {
            match err {
                case .unexpected(_) => {}
                case _ => std.panic.panic("expected unexpected error for readExact eof")
            }
        }
    }

    std.assert(reader.close().isOk(), "failed to close readExact eof file")
    std.assert(std.fs.removeFile(path).isOk(), "failed to remove readExact eof file")
}

@test
func testReadAtLeastSuccess() {
    let path = "taro_io_read_at_least_success.txt"
    let content = "abcdefg"
    let contentPtr = std.string.stringData(content)

    std.assert(std.fs.writeString(path, content).isOk(), "failed to write readAtLeast file")

    let openRes = std.fs.File.open(path)
    var reader = match openRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to open readAtLeast file")
    }

    var storage: [uint8; 8] = [0; 8]
    let storagePtr = unsafe { (&mut storage as *mut [uint8; 8]) as *mut uint8 }
    let buf = std.mem.MutableSpan[uint8].from(storagePtr, 8)
    let readRes = std.io.readAtLeast(&mut reader, 4, buf)
    let count = match readRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("readAtLeast should succeed")
    }
    std.assert(count >= 4, "readAtLeast count should be at least min")

    var idx: usize = 0
    while idx < 4 {
        std.assert(*storage.at(idx) == contentPtr.add(idx).read(), "readAtLeast leading bytes mismatch")
        idx += 1
    }

    std.assert(reader.close().isOk(), "failed to close readAtLeast file")
    std.assert(std.fs.removeFile(path).isOk(), "failed to remove readAtLeast file")
}

@test
func testReadAtLeastInvalidInput() {
    let path = "taro_io_read_at_least_invalid.txt"
    std.assert(std.fs.writeString(path, "ok").isOk(), "failed to write readAtLeast invalid file")

    let openRes = std.fs.File.open(path)
    var reader = match openRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to open readAtLeast invalid file")
    }

    var storage: [uint8; 2] = [0; 2]
    let storagePtr = unsafe { (&mut storage as *mut [uint8; 2]) as *mut uint8 }
    let buf = std.mem.MutableSpan[uint8].from(storagePtr, 2)
    let readRes = std.io.readAtLeast(&mut reader, 3, buf)
    std.assert(readRes.isErr(), "readAtLeast should fail when min > buf.len")
    match readRes {
        case .ok(_) => std.panic.panic("expected invalidInput for readAtLeast min > len")
        case .err(err) => {
            match err {
                case .invalidInput => {}
                case _ => std.panic.panic("expected invalidInput for readAtLeast min > len")
            }
        }
    }

    std.assert(reader.close().isOk(), "failed to close readAtLeast invalid file")
    std.assert(std.fs.removeFile(path).isOk(), "failed to remove readAtLeast invalid file")
}

func main() {}
