// CHECK_ONLY

import std.collections.List
import std.hash.{Hashable, DefaultHasher}
import std.optional.Optional

func hashKey[Key: Hashable](_ key: &Key) -> uint64 {
    var hasher = DefaultHasher.new()
    key.hash(into: &mut hasher)
    hasher.finish()
}

struct EqRepro[Key: Hashable, Value] {
    keys: List[Key?]
    values: List[Value?]
}

impl[Key: Hashable, Value] EqRepro[Key, Value] {
    func new(_ key: Key, _ value: Value) -> Self {
        var keys: List[Key?] = List()
        var values: List[Value?] = List()
        let entry: Key? = .some(key)
        let valueEntry: Value? = .some(value)
        keys.append(entry)
        values.append(valueEntry)
        EqRepro[Key, Value] { keys, values }
    }

    func get(&self, _ key: Key) -> Optional[&Value] {
        let _ = key
        return .none
    }

    func get(&mut self, _ key: Key) -> Optional[&mut Value] {
        let hash = hashKey(&key)
        var idx: usize = 0
        while idx < (1 as usize) {
            let keySlot: &mut Key? = self.keys.at(idx)
            match keySlot {
                case .some(existingKey) => {
                    let _ = hash
                    if key.eq(existingKey) {
                        let valueSlot: &mut Value? = self.values.at(idx)
                        match valueSlot {
                            case .some(existingValue) => {
                                return .some(existingValue)
                            }
                            case .none => {
                                return .none
                            }
                        }
                    }
                }
                case .none => {}
            }
            idx += 1
        }
        return .none
    }
}

func main() {
    var repro = EqRepro[int32, int32].new(10, 11)
    let _ = repro.get(10)
}
