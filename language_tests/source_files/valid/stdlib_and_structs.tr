
// Tests: stdlib print/string, C FFI (puts), structs, tuples, make, &mut refs.

func main() {
    usePrint()

    let combined = concatString("Hello ", "From Taro Concat!\n")
    print(combined)
    assert(std.string.stringLen(combined) > 0, "concat failed")

    let fib_res = useFib()
    assert(fib_res == 6, "fib logic failed")
    print("PASS: useFib\n")

    let block_result = withBlocks()
    assert(block_result == 20, "block logic failed")
    print("PASS: withBlocks\n")

    let point_result = usePointCompute()
    assert(point_result == true, "point compute failed")
    print("PASS: usePointCompute\n")

    let tuple_result = useTuple()
    let (t1, t2) = tuple_result
    assert(t1 == 1, "tuple.0 failed")
    assert(t2 == 2, "tuple.1 failed")
    print("PASS: useTuple\n")

    useAllocator()
    print("PASS: useAllocator\n")

    print("All tests passed!\n")
}

func usePrint() {
    print("Hello From Taro\n")
    let str = "Hello From Taro through C!"
    let ptr = std.string.stringData(str)
    puts(ptr)
    print("\n")
}

func concatString(_ a: string, _ b: string) -> string {
    let aLen = std.string.stringLen(a)
    let bLen = std.string.stringLen(b)
    let total = aLen + bLen
    let buf = std.mem.allocBytes(total)

    let aPtr = std.string.stringData(a)
    let bPtr = std.string.stringData(b)
    aPtr.copyTo(buf, aLen)
    let dstB = buf.byteAdd(aLen)
    bPtr.copyTo(dstB, bLen)

    return std.string.stringFromParts(buf, total)
}

extern "C" {
    func puts(_ s: *const uint8)
}

public func triple(_ value: int32) -> int32 {
    return value * 3
}

func useFib() -> int32  {
    let a = triple(2)
    let b = triple(3)
    useAllocator()
    return a
}

func fib(_ n: int32) -> int32 {
    if n <= 1 {
        return n
    }
    return fib(n - 1) + fib(n - 2)
}


func withBlocks() -> int32 {
    let a: int32 = triple(5)
    let b: int32 = triple(2)
    let c: int32 = if a > b {
        20
    } else {
        2
    }
    return c
}



struct Point {
    x: int32
    y: int32
}


impl Point {
    func new(_ x: int32, _ y: int32) -> &Point {
        &Point { x, y }
    }

    func isOrigin(&self) -> bool {
        self.x == 0 && self.y == 0
    }
}


func usePointCompute() -> bool {
    let a = Point { x: 1, y: 0 }
    let b = Point.new(0, 0)
    let c = Point(1,1)
    let d = c

    let d = a.isOrigin() == b.isOrigin()
    return a.x == c.x
}


func useTuple() -> (int32, int32) {
    let tuple = (0, 1)
    let (a, b) = tuple
    return (a + 1, b + tuple.1)
}


func useAllocator() {
    let x = make(Point { x: 1, y: 2 })
    updatePoint(x, value: 43)
}


func updatePoint(_ point: &mut Point, value: int32) {
    point.y = value
}


struct Testing {
    readonly a: usize
}
