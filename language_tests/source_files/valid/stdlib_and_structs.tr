
// Tests: stdlib print/string, C FFI (puts), structs, tuples, make, &mut refs.

func main() {
    usePrint()
    
    let combined = concat_string("Hello ", "From Taro Concat!\n")
    print(combined)
    assert(std.unsafe.string_len(combined) > 0, "concat failed")
    
    let fib_res = useFib()
    assert(fib_res == 6, "fib logic failed")
    print("PASS: useFib\n")
    
    let block_result = withBlocks()
    assert(block_result == 20, "block logic failed")
    print("PASS: withBlocks\n")
    
    let point_result = usePointCompute()
    assert(point_result == true, "point compute failed")
    print("PASS: usePointCompute\n")
    
    let tuple_result = useTuple()
    let (t1, t2) = tuple_result
    assert(t1 == 1, "tuple.0 failed")
    assert(t2 == 2, "tuple.1 failed")
    print("PASS: useTuple\n")
    
    useAllocator()
    print("PASS: useAllocator\n")
    
    print("All tests passed!\n")
}

func usePrint() {
    print("Hello From Taro\n")
    let str = "Hello From Taro through C!"
    let ptr = std.unsafe.string_data(str)
    puts(ptr)
    print("\n")
}

func concat_string(_ a: string, _ b: string) -> string {
    let a_len = std.unsafe.string_len(a)
    let b_len = std.unsafe.string_len(b)
    let total = a_len + b_len
    let buf = std.unsafe.alloc_bytes(total)

    let a_ptr = std.unsafe.string_data(a)
    let b_ptr = std.unsafe.string_data(b)
    buf.copy_from_raw(a_ptr, a_len)
    let dst_b = buf.add_bytes(a_len)
    dst_b.copy_from_raw(b_ptr, b_len)

    return std.unsafe.string_from_parts(buf, total)
}

extern "C" {
    func puts(_ s: *const uint8)
}

public func triple(_ value: int32) -> int32 {
    return value * 3
}

func useFib() -> int32  {
    let a = triple(2)
    let b = triple(3)
    useAllocator()
    return a
}

func fib(_ n: int32) -> int32 {
    if n <= 1 {
        return n
    }
    return fib(n - 1) + fib(n - 2)
}


func withBlocks() -> int32 {
    let a: int32 = triple(5)
    let b: int32 = triple(2)
    let c: int32 = if a > b {
        20
    } else {
        2
    }
    return c
}



struct Point {
    x: int32
    y: int32
}


impl Point {
    func new(_ x: int32, _ y: int32) -> &Point {
        &Point { x, y }
    }

    func isOrigin(&self) -> bool {
        self.x == 0 && self.y == 0
    }
}


func usePointCompute() -> bool {
    let a = Point { x: 1, y: 0 }
    let b = Point.new(0, 0)
    let c = Point(1,1)
    let d = c

    let d = a.isOrigin() == b.isOrigin()
    return a.x == c.x
}


func useTuple() -> (int32, int32) {
    let tuple = (0, 1)
    let (a, b) = tuple
    return (a + 1, b + tuple.1)
}


func useAllocator() {
    let x = make(Point { x: 1, y: 2 })
    updatePoint(x, value: 43)
}


func updatePoint(_ point: &mut Point, value: int32) {
    point.y = value
}


struct Testing {
    readonly a: usize
}
