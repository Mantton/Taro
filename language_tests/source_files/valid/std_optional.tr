// Test std.optional module
// Tests: unwrap, expect, unwrapOr, unwrapOrElse, map, flatMap, filter, and, or

func main() {
    // Test isSome/isNone
    let some_val: int32? = .some(42)
    let none_val: int32? = .none
    assert(some_val.isSome(), "isSome should be true for .some")
    assert(none_val.isNone(), "isNone should be true for .none")

    // Test unwrap
    let unwrapped = some_val.unwrap()
    assert(unwrapped == 42, "unwrap should return value")

    // Test expect
    let expected = some_val.expect("should have value")
    assert(expected == 42, "expect should return value")

    // Test unwrapOr
    let with_default = none_val.unwrapOr(100)
    assert(with_default == 100, "unwrapOr should return default for none")
    let without_default = some_val.unwrapOr(100)
    assert(without_default == 42, "unwrapOr should return value for some")

    // Test unwrapOrElse
    let computed = none_val.unwrapOrElse(|| -> int32 { 50 + 50 })
    assert(computed == 100, "unwrapOrElse should compute default")

    // Test map
    let mapped = some_val.map(|x| -> int32 { x * 2 })
    assert(mapped.unwrap() == 84, "map should transform value")

    let mapped_none = none_val.map(|x| -> int32 { x * 2 })
    assert(mapped_none.isNone(), "map on none should return none")
    // Test flatMap
    let flat_some = some_val.flatMap(|x| -> int32? { .some(x + 1) })
    assert(flat_some.unwrap() == 43, "flatMap should chain transformations")

    let flat_to_none = some_val.flatMap(|x| -> int32? { .none })
    assert(flat_to_none.isNone(), "flatMap returning none should give none")

    // Test filter
    let filtered_pass = some_val.filter(|x: &int32| -> bool { *x > 0 })
    assert(filtered_pass.isSome(), "filter passing predicate should keep value")

    let filtered_fail = some_val.filter(|x: &int32| -> bool { *x < 0 })
    assert(filtered_fail.isNone(), "filter failing predicate should return none")

    // Test and
    let other1: int32? = .some(100)
    let and_result = some_val.and(other1)
    assert(and_result.unwrap() == 100, "and should return second if first is some")

    let other2: int32? = .some(100)
    let and_none = none_val.and(other2)
    assert(and_none.isNone(), "and on none should return none")

    // Test or
    let other3: int32? = .some(100)
    let or_result = some_val.or(other3)
    assert(or_result.unwrap() == 42, "or should return first if some")

    let other4: int32? = .some(100)
    let or_fallback = none_val.or(other4)
    assert(or_fallback.unwrap() == 100, "or should return second if first is none")

    print("std_optional: PASSED\n")
}
