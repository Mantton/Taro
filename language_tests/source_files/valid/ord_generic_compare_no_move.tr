import std.cmp.{Ord, PartialOrd, Ordering}

struct Score {
    value: int32
}

impl std.ops.PartialEq for Score {
    public func eq(&self, _ other: &Score) -> bool {
        self.value == other.value
    }
}

impl PartialOrd for Score {
    func partialCmp(&self, _ other: &Score) -> Optional[Ordering] {
        .some(self.cmp(other))
    }
}

impl Ord for Score {
    func cmp(&self, _ other: &Score) -> Ordering {
        if self.value < other.value {
            .less
        } else if self.value == other.value {
            .equal
        } else {
            .greater
        }
    }
}

func geqThenReuse[T: Ord](_ a: T, _ b: T) -> bool {
    let ge = a >= b
    let _keep = &a
    ge
}

func main() {
    let a = Score { value: 1 }
    let b = Score { value: 1 }

    assert(geqThenReuse(a, b), "generic ordered comparison should borrow, not move")
    std.print("ok\n")
}
