// Test that closure trait hierarchy works correctly:
// Fn ⊂ FnMut ⊂ FnOnce
// A Fn closure should satisfy FnMut and FnOnce bounds

// Function expecting FnOnce - accepts any closure
func apply_once[F: FnOnce[int32, int32]](_ f: F, _ x: int32) -> int32 {
    f(x)
}

// Function expecting FnMut - accepts Fn or FnMut closures
func apply_mut[F: FnMut[int32, int32]](_ f: F, _ x: int32) -> int32 {
    f(x)
}

// Function expecting Fn - accepts only Fn closures
func apply_fn[F: Fn[int32, int32]](_ f: F, _ x: int32) -> int32 {
    f(x)
}

func main() {
    let multiplier: int32 = 2

    // Test 1: Fn closure with apply_fn
    let r1 = apply_fn(|x: int32| -> int32 { x * multiplier }, 5)
    std.assert(r1 == 10, "apply_fn should work with Fn closure")

    // Test 2: Fn closure with apply_mut (hierarchy: Fn satisfies FnMut)
    let r2 = apply_mut(|x: int32| -> int32 { x * multiplier }, 5)
    std.assert(r2 == 10, "apply_mut should accept Fn closure via hierarchy")

    // Test 3: Fn closure with apply_once (hierarchy: Fn satisfies FnOnce)
    let r3 = apply_once(|x: int32| -> int32 { x * multiplier }, 5)
    std.assert(r3 == 10, "apply_once should accept Fn closure via hierarchy")

    // Test 4: Non-capturing closure (Fn kind) with apply_once
    let r4 = apply_once(|x: int32| -> int32 { x + 1 }, 5)
    std.assert(r4 == 6, "non-capturing Fn closure in apply_once")

    // Test 5: Non-capturing closure with apply_mut
    let r5 = apply_mut(|x: int32| -> int32 { x * 3 }, 4)
    std.assert(r5 == 12, "non-capturing Fn closure in apply_mut")

    std.print("closure_hierarchy: PASSED\n")
}
