// Test closures as parameters in methods (non-generic struct)

struct Container {
    value: int32
}

impl Container {
    // Method with Fn bound - can call multiple times, shared access
    func map[F: Fn[int32, int32]](&self, _ f: F) -> int32 {
        f(self.value)
    }

    // Method with FnOnce bound - consumes the closure
    func map_once[F: FnOnce[int32, int32]](&self, _ f: F) -> int32 {
        f(self.value)
    }

    // Chained transformation with two Fn closures
    func transform[F: Fn[int32, int32], G: Fn[int32, int32]](&self, _ f: F, _ g: G) -> int32 {
        g(f(self.value))
    }
}

struct Pair {
    a: int32
    b: int32
}

impl Pair {
    // Method taking two-arg closure (unpacked tuple ABI)
    func combine[F: Fn[(int32, int32), int32]](&self, _ f: F) -> int32 {
        f(self.a, self.b)  // Unpacked - no tuple construction
    }
}

func main() {
    let container = Container { value: 10 }

    // Test Fn bound method with non-capturing closure
    let doubled = container.map(|x: int32| -> int32 { x * 2 })
    std.assert(doubled == 20, "map double should be 20")

    // Test Fn bound method with capturing closure
    let multiplier: int32 = 3
    let tripled = container.map(|x: int32| -> int32 { x * multiplier })
    std.assert(tripled == 30, "map triple should be 30")

    // Test FnOnce bound method
    let offset: int32 = 5
    let result_once = container.map_once(|x: int32| -> int32 { x + offset })
    std.assert(result_once == 15, "map_once should be 15")

    // Test chained transformations
    let chained = container.transform(
        |x: int32| -> int32 { x + 5 },
        |x: int32| -> int32 { x * 2 },
    )
    std.assert(chained == 30, "transform (10+5)*2 should be 30")

    // Test two-arg closure in method (unpacked tuple ABI)
    let pair = Pair { a: 10, b: 20 }
    let sum = pair.combine(|a: int32, b: int32| -> int32 { a + b })
    std.assert(sum == 30, "combine sum should be 30")

    std.print("closure_method: PASSED\n")
}
