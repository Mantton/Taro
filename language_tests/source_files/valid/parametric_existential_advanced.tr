// Test: Parametric Existential Advanced
// Tests existential types with associated type bindings in function returns
// This file explores the normalization of existential projections

type int = isize

interface Producer {
    type Output
    func produce(&self) -> Self.Output
}

struct IntProducer {}

impl Producer for IntProducer {
    type Output = int
    func produce(&self) -> int { 42 }
}

struct StringProducer {}

impl Producer for StringProducer {
    type Output = string
    func produce(&self) -> string { "hello" }
}

// Test 1: Existential with associated type binding - function parameter
// Expected: p.produce() should return `int` since `any Producer[Output = int].Output` should normalize to `int`
func consumeIntProducer(_ p: any Producer[Output = int]) -> int {
    p.produce()
}

// Test 2: Existential with associated type binding for string
func consumeStringProducer(_ p: any Producer[Output = string]) -> string {
    p.produce()
}

// Test 3: Generic function returning existential with binding
func makeIntProducer() -> any Producer[Output = int] {
    IntProducer {}
}

func main() {
    // Test direct existential assignment with binding
    let intP: any Producer[Output = int] = IntProducer {}
    let result1 = intP.produce()
    assert(result1 == 42, "Direct existential assignment failed")

    // Test function parameter with existential binding
    let intP2 = IntProducer {}
    let result2 = consumeIntProducer(intP2)
    assert(result2 == 42, "Function parameter existential failed")

    // Test string variant
    let strP = StringProducer {}
    let result3 = consumeStringProducer(strP)
    assert(result3 == "hello", "String producer failed")

    // Test function returning existential with binding
    let intP3: any Producer[Output = int] = makeIntProducer()
    let result4 = intP3.produce()
    assert(result4 == 42, "Return existential with binding failed")

    std.print("PASS: Parametric existential advanced\n")
}
