// TEST

@test
func testMetadataForFileAndDir() {
    let root = "taro_fs_metadata_root"
    let nested = "taro_fs_metadata_root/a/b"
    let filePath = "taro_fs_metadata_root/a/b/data.txt"
    let content = "hello"

    std.assert(std.fs.createDirAll(nested).isOk(), "failed to create nested directories")
    std.assert(std.fs.writeString(filePath, content).isOk(), "failed to write metadata file")

    let fileMetaRes = std.fs.metadata(filePath)
    let fileMeta = match fileMetaRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to read file metadata")
    }
    std.assert(fileMeta.isFile(), "file metadata should report file")
    std.assert(!fileMeta.isDir(), "file metadata should not report directory")
    std.assert(!fileMeta.isSymlink(), "file metadata should not report symlink")
    std.assert(fileMeta.len() == std.string.stringLen(content), "file metadata size mismatch")
    let _ = fileMeta.isReadonly()
    std.assert(fileMeta.modifiedSeconds() >= (-1 as int64), "modifiedSeconds should be populated or -1")
    std.assert(fileMeta.accessedSeconds() >= (-1 as int64), "accessedSeconds should be populated or -1")
    std.assert(fileMeta.createdSeconds() >= (-1 as int64), "createdSeconds should be populated or -1")

    let statRes = std.fs.stat(filePath)
    let statMeta = match statRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to stat file metadata")
    }
    std.assert(statMeta.isFile(), "stat should report file")
    std.assert(statMeta.len() == std.string.stringLen(content), "stat size mismatch")

    let dirMetaRes = std.fs.metadata(nested)
    let dirMeta = match dirMetaRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to read directory metadata")
    }
    std.assert(dirMeta.isDir(), "directory metadata should report directory")
    std.assert(!dirMeta.isFile(), "directory metadata should not report file")
    std.assert(!dirMeta.isSymlink(), "directory metadata should not report symlink")

    std.assert(std.fs.removeDirAll(root).isOk(), "failed to cleanup metadata root")
}

@test
func testCreateDirAllIsIdempotent() {
    let root = "taro_fs_create_dir_all_root"
    let nested = "taro_fs_create_dir_all_root/x/y/z"

    std.assert(std.fs.createDirAll(nested).isOk(), "first createDirAll should succeed")
    std.assert(std.fs.createDirAll(nested).isOk(), "second createDirAll should succeed")
    std.assert(std.fs.removeDirAll(root).isOk(), "failed to cleanup createDirAll root")
}

@test
func testRemoveDirAllRemovesNestedTree() {
    let root = "taro_fs_remove_dir_all_root"
    let nested = "taro_fs_remove_dir_all_root/one/two"
    let filePath = "taro_fs_remove_dir_all_root/one/two/value.txt"

    std.assert(std.fs.createDirAll(nested).isOk(), "failed to create removeDirAll tree")
    std.assert(std.fs.writeString(filePath, "value").isOk(), "failed to create removeDirAll file")
    std.assert(std.fs.removeDirAll(root).isOk(), "removeDirAll should succeed")

    let metaRes = std.fs.metadata(root)
    std.assert(metaRes.isErr(), "metadata should fail after removeDirAll")
    match metaRes {
        case .ok(_) => std.panic.panic("expected metadata to fail after removeDirAll")
        case .err(err) => {
            match err {
                case .notFound => {}
                case _ => std.panic.panic("expected notFound after removeDirAll")
            }
        }
    }
}

@test
func testRemoveDirAllMissingReturnsNotFound() {
    let missing = "taro_fs_remove_dir_all_missing_path"
    let res = std.fs.removeDirAll(missing)
    std.assert(res.isErr(), "removeDirAll on missing path should fail")

    match res {
        case .ok(_) => std.panic.panic("expected removeDirAll missing to fail")
        case .err(err) => {
            match err {
                case .notFound => {}
                case _ => std.panic.panic("expected notFound for missing removeDirAll")
            }
        }
    }
}

func main() {}
