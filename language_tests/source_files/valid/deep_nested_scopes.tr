
// Helper Enum
enum IntOutcome {
    case success(int32)
    case failure
}

func make_success(_ val: int32) -> IntOutcome {
    return IntOutcome.success(val)
}

// Generic Helper
func ident[T](_ val: T) -> T {
    return val
}

// Iterator Support
struct RangeIterator {
    current: int32
    end: int32
}

impl Iterator for RangeIterator {
    type Element = int32

    func next(&mut self) -> Optional[int32] {
        if self.current < self.end {
            let value = self.current
            self.current = self.current + 1
            return Optional.some(value)
        }
        return Optional.none
    }
}

struct SimpleRange {
    start: int32
    end: int32
}

impl Iterable for SimpleRange {
    type Iterator = RangeIterator
    type Element = int32

    func makeIterator(self) -> RangeIterator {
        return RangeIterator { current: self.start, end: self.end }
    }
}

func test_deep_nesting() {
    // Level 1: Variable pending inference
    var x = IntOutcome.failure 

    // Level 2: If statement
    if true {
        // Level 3: Nested Block
        {
            // Level 4: For Loop
            let range = SimpleRange { start: 0, end: 1 }
            for i in range {
                // Level 5: Match expression on generic call result
                match ident(make_success(i)) {
                    case .success(val) => {
                         // Level 6: If/Else
                         if val >= 0 {
                             // Level 7: Additional For Loop
                             let nested_range = SimpleRange { start: 0, end: 1 }
                             for k in nested_range {
                                 // Level 8: Additional Match
                                 match make_success(k) {
                                     case .success(loop_val) => {
                                         // Level 9: Block
                                         {
                                             // Level 10: Global Generic Call
                                             let y = ident(val + loop_val)
                                             
                                             // Level 11: Nested Match
                                             match make_success(y) {
                                                 case .success(inner) => {
                                                     // Level 12: Assignment validating inference
                                                     x = IntOutcome.success(inner)
                                                 }
                                                 case .failure => {}
                                             }
                                         }
                                     }
                                     case .failure => {}
                                 }
                             }
                         } else {
                             // Level 7 nested else
                         }
                    }
                    case .failure => {}
                }
                
                // Exit early as requested
                break
            }
        }
    }

    // Validation: x should be inferred as IntOutcome
    match x {
        case .success(v) => {
            assert(v == 0, "Deep nesting inference failed value check")
        }
        case .failure => {
            // It was initialized as failure, deeply assigned to success(0)
            assert(false, "Should have been assigned in deep nest")
        }
    }
}

func main() {
    test_deep_nesting()
    print("Deep nested scopes test passed!\n")
}
