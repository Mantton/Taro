// Test: Generic Constraints Complex
// Checks complex where-clause constraints involving associated types.

func main() {

    let user = User { id: 42, name: "Alice" }
    let boxU = BoxU { value: 99 }
    let boxS = BoxS { value: "Hello" }

    let _u: usize = takeItem(boxU)
    let _s: string = takeItem(boxS)

    printStringContainer(boxS)

    let _u2: usize = takeU2(BoxU2 { value: 123 })

    showEntity(user)
    
    std.print("PASS: Complex constraints verified\n")
}

interface Container {
    type Item
    func get(&self) -> Self.Item
}

struct BoxU: Copyable { value: usize }
extend BoxU: Container {
    type Item = usize
    func get(&self) -> usize { self.value }
}

struct BoxS: Copyable { value: string }
extend BoxS: Container {
    type Item = string
    func get(&self) -> string { self.value }
}

func takeItem[T: Container](_ c: T) -> T.Item {
    let v: T.Item = c.get()
    v
}

func printStringContainer[T](_ c: T) where T: Container, T.Item == string {
    let s: string = c.get()
    assert(s == "Hello", "String container value")
}

interface Container2[T] {
    func get(&self) -> T
}

struct BoxU2: Copyable { value: usize }
extend BoxU2: Container2[usize] {
    func get(&self) -> usize { self.value }
}

func takeU2[T: Container2[usize]](_ c: T) -> usize {
    c.get()
}

interface Named {
    func name(&self) -> string
}

interface Entity: Named {
    func id(&self) -> usize
}

struct User: Copyable {
    id: usize
    name: string
}

extend User: Entity {
    func name(&self) -> string { self.name }
    func id(&self) -> usize { self.id }
}

func showEntity(_ value: any Entity) {
    assert(value.name() == "Alice", "Entity name check")
}
