// TEST

import std.io.{Reader, Writer}

@test
func testWriteStringAndReadToString() {
    let path = "taro_io_helpers_text.txt"
    let text = "hello io helpers\nline two"

    let createRes = std.fs.File.create(path)
    var writer = match createRes {
        case .ok(file) => file
        case .err(_) => std.panic.panic("failed to create test file")
    }

    let writeRes = std.io.writeString(&mut writer, text)
    std.assert(writeRes.isOk(), "writeString failed")

    let closeWriteRes = writer.close()
    std.assert(closeWriteRes.isOk(), "failed to close writer")

    let openRes = std.fs.File.open(path)
    var reader = match openRes {
        case .ok(file) => file
        case .err(_) => std.panic.panic("failed to open test file")
    }

    let readRes = std.io.readToString(&mut reader)
    let readText = match readRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("readToString failed")
    }

    std.assert(std.string.stringEq(readText, text), "readToString content mismatch")

    let closeReadRes = reader.close()
    std.assert(closeReadRes.isOk(), "failed to close reader")

    let removeRes = std.fs.removeFile(path)
    std.assert(removeRes.isOk(), "failed to remove text file")
}

@test
func testWriteAllReadAllAndCopy() {
    let srcPath = "taro_io_helpers_src.bin"
    let dstPath = "taro_io_helpers_dst.bin"
    let text = "copy me through io.copy"
    let textLen = std.string.stringLen(text)
    let textPtr = std.string.stringData(text)
    let textBytes = std.mem.Span[uint8].from(textPtr, textLen)

    let createSrcRes = std.fs.File.create(srcPath)
    var srcWriter = match createSrcRes {
        case .ok(file) => file
        case .err(_) => std.panic.panic("failed to create src file")
    }

    let writeAllRes = std.io.writeAll(&mut srcWriter, textBytes)
    std.assert(writeAllRes.isOk(), "writeAll failed")
    std.assert(srcWriter.close().isOk(), "failed to close src writer")

    let openSrcRes = std.fs.File.open(srcPath)
    var srcReader = match openSrcRes {
        case .ok(file) => file
        case .err(_) => std.panic.panic("failed to open src file")
    }

    let readAllRes = std.io.readAll(&mut srcReader)
    let bytes = match readAllRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("readAll failed")
    }
    std.assert(bytes.len() == textLen, "readAll length mismatch")
    std.assert(srcReader.close().isOk(), "failed to close src reader after readAll")

    let openSrcCopyRes = std.fs.File.open(srcPath)
    var srcForCopy = match openSrcCopyRes {
        case .ok(file) => file
        case .err(_) => std.panic.panic("failed to reopen src file")
    }

    let createDstRes = std.fs.File.create(dstPath)
    var dstWriter = match createDstRes {
        case .ok(file) => file
        case .err(_) => std.panic.panic("failed to create dst file")
    }

    let copyRes = std.io.copy(&mut srcForCopy, &mut dstWriter)
    std.assert(copyRes.isOk(), "copy failed")
    std.assert(copyRes.unwrap() == textLen, "copy byte count mismatch")
    std.assert(srcForCopy.close().isOk(), "failed to close src copy reader")
    std.assert(dstWriter.close().isOk(), "failed to close dst writer")

    let openDstRes = std.fs.File.open(dstPath)
    var dstReader = match openDstRes {
        case .ok(file) => file
        case .err(_) => std.panic.panic("failed to open dst file")
    }

    let readBackRes = std.io.readToString(&mut dstReader)
    let readBack = match readBackRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to read dst file")
    }
    std.assert(std.string.stringEq(readBack, text), "copied content mismatch")
    std.assert(dstReader.close().isOk(), "failed to close dst reader")

    std.assert(std.fs.removeFile(srcPath).isOk(), "failed to remove src file")
    std.assert(std.fs.removeFile(dstPath).isOk(), "failed to remove dst file")
}

func main() {}
