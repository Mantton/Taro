// Test: Inferred Members
// Checks context-sensitive Member Access (.some, .none).

func main() {

    let a: int32? = .none
    let b: int32? = .some(1)

    match a {
        case .some(_) => {
             assert(false, "a is none")
        }
        case .none => {
             assert(true, "a match none")
        }
    }

    match b {
        case .some(_) => {
            assert(true, "b match some")
        }
        case .none => {
            assert(false, "b is some")
        }
    }
    
    test_inferred_expr_contexts()
    test_call_context()
    
    std.print("PASS: Inferred members resolved\n")
}

func f() -> int32? {
    return .none
}
func g() -> int32? {
    return .some(42)
}

func test_inferred_expr_contexts() {
    // assignment with type annotation
    let x: int32? = .some(7)
    let y: int32? = .none

    // conditional expression
    let z: int32? = if true { .some(1) } else { .none }

    // match expression with inferred result
    let m: int32? = match true {
        case true => .some(9)
        case false => .none
    }
}

func test_call_context() {
    // inferred callee type comes from expected result
    func makeOpt() -> int32? {
        return .some(5)
    }
    let v: int32? = makeOpt()
}

func test_asi_newline_continuation() {
    // ASI: leading dot continues previous line
    let a: int32? =
        .none

    let b: int32? =
        .some(3)

    // this should be parsed as a member access, not a new statement
    let c: int32? = .some(4)
    c
        .isSome()
}

func test_nested_generic() {
    // Optional of Optional
    let a: int32?? = .some(.none)
    let b: int32?? = .some(.some(1))
}

func takesOpt(_ v: int32?) {}
func test_expected_from_call() {
    // expectation flows from argument position
    takesOpt(.none)
    takesOpt(.some(11))
}
