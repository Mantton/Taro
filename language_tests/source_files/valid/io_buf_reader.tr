// TEST

@test
func testBufReaderReadLine() {
    let path = "taro_io_buf_reader_lines.txt"
    let content = "alpha\nbeta\n"

    let writeRes = std.fs.writeString(path, content)
    std.assert(writeRes.isOk(), "failed to write line test file")

    let openRes = std.fs.File.open(path)
    let file = match openRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to open line test file")
    }

    var reader = std.io.BufReader[std.fs.File].new(file)

    let line1Res = reader.readLine()
    let line1 = match line1Res {
        case .ok(opt) => opt
        case .err(_) => std.panic.panic("readLine 1 failed")
    }
    match line1 {
        case .some(value) => std.assert(std.string.stringEq(value, "alpha\n"), "line 1 mismatch")
        case .none => std.panic.panic("line 1 missing")
    }

    let line2Res = reader.readLine()
    let line2 = match line2Res {
        case .ok(opt) => opt
        case .err(_) => std.panic.panic("readLine 2 failed")
    }
    match line2 {
        case .some(value) => std.assert(std.string.stringEq(value, "beta\n"), "line 2 mismatch")
        case .none => std.panic.panic("line 2 missing")
    }

    let line3Res = reader.readLine()
    let line3 = match line3Res {
        case .ok(opt) => opt
        case .err(_) => std.panic.panic("readLine 3 failed")
    }
    std.assert(line3.isNone(), "expected EOF after two lines")

    var inner = reader.intoInner()
    std.assert(inner.close().isOk(), "failed to close line test file")
    std.assert(std.fs.removeFile(path).isOk(), "failed to remove line test file")
}

@test
func testBufReaderImplementsReader() {
    let path = "taro_io_buf_reader_read_to_string.txt"
    let content = "one\ntwo\nthree\n"

    let writeRes = std.fs.writeString(path, content)
    std.assert(writeRes.isOk(), "failed to write reader test file")

    let openRes = std.fs.File.open(path)
    let file = match openRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("failed to open reader test file")
    }

    var reader = std.io.BufReader[std.fs.File].new(file)
    let readRes = std.io.readToString(&mut reader)
    let text = match readRes {
        case .ok(value) => value
        case .err(_) => std.panic.panic("readToString with BufReader failed")
    }
    std.assert(std.string.stringEq(text, content), "BufReader Reader impl mismatch")

    var inner = reader.intoInner()
    std.assert(inner.close().isOk(), "failed to close reader test file")
    std.assert(std.fs.removeFile(path).isOk(), "failed to remove reader test file")
}

func main() {}
